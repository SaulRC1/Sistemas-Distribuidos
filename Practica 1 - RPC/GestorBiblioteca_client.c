/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "GestorBiblioteca.h"
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>

#define Cls system("clear")
#define Pause system("read -p \"Pulsa una tecla para continuar..... \" a")
#define MostrarAviso(Texto) \
	{                       \
		printf(Texto);      \
		Pause;              \
	}

void gestorbiblioteca_1(char *host)
{
	CLIENT *clnt;
	int *result_1;
	char conexion_1_arg;
	bool_t *result_2;
	int desconexion_1_arg;
	int *result_3;
	TConsulta cargardatos_1_arg;
	bool_t *result_4;
	int guardardatos_1_arg;
	int *result_5;
	TNuevo nuevolibro_1_arg;
	int *result_6;
	TComRet comprar_1_arg;
	int *result_7;
	TComRet retirar_1_arg;
	bool_t *result_8;
	TOrdenacion ordenar_1_arg;
	int *result_9;
	int nlibros_1_arg;
	int *result_10;
	TConsulta buscar_1_arg;
	TLibro *result_11;
	TPosicion descargar_1_arg;
	int *result_12;
	TPosicion prestar_1_arg;
	int *result_13;
	TPosicion devolver_1_arg;

#ifndef DEBUG
	clnt = clnt_create(host, GESTORBIBLIOTECA, GESTORBIBLIOTECA_VER, "tcp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */

	result_1 = conexion_1(&conexion_1_arg, clnt);
	if (result_1 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_2 = desconexion_1(&desconexion_1_arg, clnt);
	if (result_2 == (bool_t *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_3 = cargardatos_1(&cargardatos_1_arg, clnt);
	if (result_3 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_4 = guardardatos_1(&guardardatos_1_arg, clnt);
	if (result_4 == (bool_t *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_5 = nuevolibro_1(&nuevolibro_1_arg, clnt);
	if (result_5 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_6 = comprar_1(&comprar_1_arg, clnt);
	if (result_6 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_7 = retirar_1(&retirar_1_arg, clnt);
	if (result_7 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_8 = ordenar_1(&ordenar_1_arg, clnt);
	if (result_8 == (bool_t *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_9 = nlibros_1(&nlibros_1_arg, clnt);
	if (result_9 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_10 = buscar_1(&buscar_1_arg, clnt);
	if (result_10 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_11 = descargar_1(&descargar_1_arg, clnt);
	if (result_11 == (TLibro *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_12 = prestar_1(&prestar_1_arg, clnt);
	if (result_12 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
	result_13 = devolver_1(&devolver_1_arg, clnt);
	if (result_13 == (int *)NULL)
	{
		clnt_perror(clnt, "call failed");
	}
#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
}

struct BookValidationResult {
	bool_t validation_result;
	Cadena error;
};

typedef struct BookValidationResult BookValidationResult;

int MenuPrincipal()
{
	int Salida;
	do
	{
		Cls;
		printf(" GESTOR BIBLIOTECARIO 1.0 (M. PRINCIPAL)\n");
		printf("*****************************************\n");
		printf("\t1.- M. Administración\n");
		printf("\t2.- Consulta de libros\n");
		printf("\t3.- Prestamos libros\n");
		printf("\t4.- Devolver libros\n");
		printf("\t0.- Salir\n\n");
		printf(" Elige opción: ");
		scanf("%d", &Salida);
		if (Salida < 0 || Salida > 4)
			MostrarAviso("\n\n *** Error en la entrada de Datos.***\n\n");
	} while (Salida < 0 || Salida > 5);
	return Salida;
}

int MenuAdministracion()
{
	int Salida;
	do
	{
		Cls;
		printf(" GESTOR BIBLIOTECARIO 1.0 (M. ADMINISTRACION)\n");
		printf("**********************************************\n");
		printf("\t1.- Cargar datos Biblioteca\n");
		printf("\t2.- Guardar datos Biblioteca\n");
		printf("\t3.- Nuevo libro\n");
		printf("\t4.- Comprar libros\n");
		printf("\t5.- Retirar libros\n");
		printf("\t6.- Ordenar libros\n");
		printf("\t7.- Buscar libros\n");
		printf("\t8.- Listar libros\n");
		printf("\t0.- Salir\n\n");
		printf(" Elige opción: ");
		scanf("%d", &Salida);
		if (Salida < 0 || Salida > 8)
			MostrarAviso("\n\n *** Error en la entrada de Datos.***\n\n");
	} while (Salida < 0 || Salida > 8);
	return Salida;
}

void Formatea(char *Salida, const char *p, int ancho, char Caracter)
{
	Cadena vacia;
	int len = ancho - strlen(p);
	int l = 0, c = 0;

	while (p[l] != '\0')
	{
		if ((unsigned char)p[l] > 128)
			c++;
		l++;
	}
	len += c / 2;

	if (len < 0)
		len = 0;
	for (int i = 0; i < len; i++)
		vacia[i] = Caracter;
	vacia[len] = '\0';

	sprintf(Salida, "%s%s", p, vacia);
}

void MostrarLibro(TLibro *L, int Pos, bool_t Cabecera)
{
	Cadena T, A, B, PI;
	if (Cabecera == TRUE)
	{
		printf("%-*s%-*s%-*s%*s%*s%*s\n", 5, "POS", 58, "TITULO", 18, "ISBN", 4, "DIS", 4, "PRE", 4, "RES");
		printf("     %-*s%-*s%-*s\n", 30, "AUTOR", 28, "PAIS (IDIOMA)", 12, "AÑO");
		Formatea(B, "*", 93, '*');
		printf("%s\n", B);
	}
	Formatea(T, L->Titulo, 58, ' ');
	Formatea(A, L->Autor, 30, ' ');
	strcpy(B, L->Pais);
	strcat(B, " (");
	strcat(B, L->Idioma);
	strcat(B, ")");
	Formatea(PI, B, 28, ' ');
	printf("%-5d%s%-*s%*d%*d%*d\n", Pos + 1, T, 18, L->Isbn, 4, L->NoLibros, 4, L->NoPrestados, 4, L->NoListaEspera);
	printf("     %s%s%-*d\n", A, PI, 12, L->Anio);
}

char * underline_string(char *source_string, char *substring)
{
	printf("Source string: %s\n", source_string);
	printf("Substring: %s\n", substring);

	//strlen does not count the terminating \0 character.
	int source_string_length = strlen(source_string) + 1;

	//starting underline string (\033[4m) is 7 characters long, and 
	//the end underline string (\033[24m) is 8 characters long, for a total
	//of 15 characters.
	int underlined_string_length = source_string_length + 15;

	char *underlined_string = malloc(source_string_length * sizeof(char));

	strcpy(underlined_string, source_string);

	printf("Underlined string #1: %s\n", underlined_string);
	
	char *occurrence_substring = strstr(underlined_string, substring);

	if(occurrence_substring != NULL)
	{
		printf("Occurrence substring: %s\n", occurrence_substring);
		char *underlined_substring = 
		malloc((strlen(occurrence_substring) + 1 + 15) * sizeof(char));

		char *occurrence_substring_copy = 
		malloc((strlen(occurrence_substring) + 1) * sizeof(char));

		strcpy(occurrence_substring_copy, occurrence_substring);

		strcpy(underlined_substring, "\033[4m");
		strcat(underlined_substring, occurrence_substring_copy);
		strcat(underlined_substring, "\033[24m");

		printf("Underlined substring: %s\n", underlined_substring);

		strcpy(occurrence_substring, underlined_substring);

		printf("Underlined string: %s\n", underlined_string);

		return underlined_string;
	}

	return NULL;
}

void search_book(Cadena search_text, char search_code, TLibro *book, 
int book_position, bool_t *first_book)
{
	if (search_code == 'I' || search_code == 'i')
	{
		char *result = strstr(book->Isbn, search_text);

		if(result != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
	else if(search_code == 'T' || search_code == 't')
	{
		char *result = strstr(book->Titulo, search_text);

		if(result != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
	else if(search_code == 'T' || search_code == 't')
	{
		char *result = strstr(book->Titulo, search_text);

		if(result != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
	else if(search_code == 'A' || search_code == 'a')
	{
		char *result = strstr(book->Autor, search_text);

		if(result != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
	else if(search_code == 'P' || search_code == 'p')
	{
		char *result = strstr(book->Pais, search_text);

		if(result != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
	else if(search_code == 'D' || search_code == 'd')
	{
		char *result = strstr(book->Idioma, search_text);

		if(result != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
	else if(search_code == '*')
	{
		char *result_I = strstr(book->Isbn, search_text);
		char *result_T = strstr(book->Titulo, search_text);
		char *result_A = strstr(book->Autor, search_text);
		char *result_P = strstr(book->Pais, search_text);
		char *result_D = strstr(book->Idioma, search_text);

		if(result_I != NULL || result_T != NULL || result_A != NULL
		|| result_P != NULL || result_D != NULL)
		{
			//underline_string(book->Isbn, search_text);

			MostrarLibro(book, book_position, *first_book);

			*first_book = FALSE;
		}
	}
}

//Returns false if no book is found, true otherwise
bool_t search_library(Cadena search_text, char search_code, 
int number_of_books, int id_admin, CLIENT *clnt)
{
	bool_t first_book = TRUE;

	for (int i = 0; i < number_of_books; i++)
	{
		TPosicion book_position_struct;
		book_position_struct.Ida = id_admin;
		book_position_struct.Pos = i;

		TLibro *book = descargar_1(&book_position_struct, clnt);

		if (book == (TLibro *)NULL)
		{
			clnt_perror(clnt, "La llamada a la función ha fallado\n");
			Pause;
			return FALSE;
		}

		search_book(search_text, search_code, book, i, &first_book);
	}

	if(first_book == TRUE)
	{
		printf("Error: no se ha encontrado ningún libro. \n");
		return FALSE;
	}

	return TRUE;
}

void handleAdminMenuOption0(int id_admin, CLIENT *clnt)
{
	bool_t *disconnection_result = desconexion_1(&id_admin, clnt);

	if (disconnection_result == (bool_t *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if (*disconnection_result == TRUE)
	{
		printf("Administrador desconectado\n");
		Pause;
	}
	else if (*disconnection_result == FALSE)
	{
		printf("ID de administrador no coincide con la alojada en el servidor, \
					se procederá a cerrar su sesión\n");
		Pause;
		exit(1);
	}
}

void handleAdminMenuOption1(int id_admin, CLIENT *clnt)
{
	Cls;

	Cadena file_name;

	printf("Introduce el nombre del fichero de datos: ");
	__fpurge(stdin);
	scanf("%s", file_name);

	TConsulta query;
	query.Ida = id_admin;
	strcpy(query.Datos, file_name);

	int *result = cargardatos_1(&query, clnt);

	if (result == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*result == -1)
	{
		printf("Ya hay un usuario identificado como administrador, o bien el ID de administrador " \
		"no coincide.\n");
		Pause;
	}
	else if(*result == 0)
	{
		printf("Error al cargar los datos de la biblioteca\n");
		Pause;
	}
	else if(*result == 1)
	{
		printf("** La biblioteca ha sido cargada **\n");
		Pause;
	}
}

void handleAdminMenuOption2(int id_admin, CLIENT *clnt)
{
	Cls;

	int *number_of_books = nlibros_1(&id_admin, clnt);

	if (number_of_books == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*number_of_books == 0)
	{
		printf("Error: No hay libros cargados en la biblioteca. " \
		"No se han guardado los datos.\n");
		Pause;
		return;
	}

	bool_t *result = guardardatos_1(&id_admin, clnt);

	if (result == (bool_t *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*result == FALSE)
	{
		printf("Error: No se han podido guardar los datos de la biblioteca\n");
		Pause;
	}
	else
	{
		printf("** Se ha guardado el estado actual de la biblioteca **\n");
		Pause;
	}
}

bool_t is_empty(char *string)
{
	if(strlen(string) == 0)
	{
		return TRUE;
	}

	return FALSE;
}

bool_t is_blank(char *string)
{
	if(is_empty(string) == TRUE)
	{
		return TRUE;
	}

	int length = strlen(string);
	
	bool_t is_blank = TRUE;

	for (int i = 0; i < length; i++)
	{
		if(!isspace(string[i]))
		{
			is_blank = FALSE;
			break;
		}
	}
	
	return is_blank;
}

BookValidationResult validateBook(TLibro book)
{
	BookValidationResult book_validation_result;

	if(is_empty(book.Isbn) || is_blank(book.Isbn))
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "No se ha introducido ISBN");
		return book_validation_result;
	}

	if(is_empty(book.Titulo) || is_blank(book.Titulo))
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El titulo del libro no es válido");
		return book_validation_result;
	}

	if(is_empty(book.Autor) || is_blank(book.Autor))
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El autor introducido no es válido");
		return book_validation_result;
	}

	if(book.Anio < 0)
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El año introducido no es válido");
		return book_validation_result;
	}

	if(is_empty(book.Pais) || is_blank(book.Pais))
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El país introducido no es válido");
		return book_validation_result;
	}

	if(is_empty(book.Idioma) || is_blank(book.Idioma))
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El idioma introducido no es válido");
		return book_validation_result;
	}

	//At least one book must be available
	if(book.NoLibros <= 0)
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El nº de libros introducido no es válido");
		return book_validation_result;
	}

	if(book.NoPrestados < 0)
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El nº de ejemplares prestados introducido no es válido");
		return book_validation_result;
	}

	if(book.NoListaEspera < 0)
	{
		book_validation_result.validation_result = FALSE;
		strcpy(book_validation_result.error, "El nº de ejemplares en lista de espera introducido no es válido");
		return book_validation_result;
	}

	book_validation_result.validation_result = TRUE;
	strcpy(book_validation_result.error, "");

	return book_validation_result;
}

void handleAdminMenuOption3(int id_admin, CLIENT *clnt)
{
	Cls;

	Cadena isbn;
	Cadena author;
	Cadena title;
	int year;
	Cadena country;
	Cadena language;
	int number_of_books;

	printf("Introduce el Isbn: ");
	__fpurge(stdin);
	scanf("%s", isbn);

	printf("Introduce el Autor: ");
	__fpurge(stdin);
	scanf("%[^\n]s", author);

	printf("Introduce el Título: ");
	__fpurge(stdin);
	scanf("%[^\n]s", title);

	printf("Introduce el año: ");
	__fpurge(stdin);
	scanf("%d", &year);

	printf("Introduce el País: ");
	__fpurge(stdin);
	scanf("%[^\n]s", country);

	printf("Introduce el Idioma: ");
	__fpurge(stdin);
	scanf("%s", language);

	printf("Introduce el Número de Libros Inicial: ");
	__fpurge(stdin);
	scanf("%d", &number_of_books);

	TLibro book;
	
	strcpy(book.Isbn, isbn);
	strcpy(book.Autor, author);
	strcpy(book.Titulo, title);
	book.Anio = year;
	strcpy(book.Pais, country);
	strcpy(book.Idioma, language);
	book.NoLibros = number_of_books;
	book.NoPrestados = 0;
	book.NoListaEspera = 0;

	BookValidationResult book_validation_result = validateBook(book);

	//FALSE means that there has been an error
	if(book_validation_result.validation_result == FALSE)
	{
		printf("ISBN: %s\n", book.Isbn);
		printf("Autor: %s\n", book.Autor);
		printf("Titulo: %s\n", book.Titulo);
		printf("Anio: %d\n", book.Anio);
		printf("Pais: %s\n", book.Pais);
		printf("Idioma: %s\n", book.Idioma);
		printf("N libros: %d\n", book.NoLibros);

		printf("Error: %s\n", book_validation_result.error);
		Pause;
		return;
	}

	TNuevo new_book;
	
	new_book.Ida = id_admin;
	new_book.Libro = book;

	int *result = nuevolibro_1(&new_book, clnt);

	if (result == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*result == -1)
	{
		printf("Error: ya hay un usuario identificado como administrador o el Ida no coincide con el almacenado en el servidor\n");
		Pause;
	}
	else if(*result == 0)
	{
		printf("Error: Hay un libro en el vector dinámico que tiene el mismo Isbn\n");
		Pause;
	}
	else if(*result == 1)
	{
		printf("Se ha añadido el nuevo libro con éxito\n");
		Pause;
	}
	else if(*result == -2)
	{
		printf("Error: No hay ninguna biblioteca cargada\n");
		Pause;
	}
}

void handleAdminMenuOption4(int id_admin, CLIENT *clnt)
{
	Cls;

	int *number_of_books = nlibros_1(&id_admin, clnt);

	if (number_of_books == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*number_of_books == 0)
	{
		printf("No hay libros cargados en la biblioteca.\n");
		Pause;
		return;
	}

	Cadena isbn;

	printf("Introduce ISBN a buscar: ");
	__fpurge(stdin);
	scanf("%s", isbn);

	TConsulta search_book;
	strcpy(search_book.Datos, isbn);
	search_book.Ida = id_admin;

	int *book_position = buscar_1(&search_book, clnt);

	if (book_position == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*book_position == -1)
	{
		printf("Error: No se ha encontrado ningún libro con el ISBN indicado.\n");
		Pause;
		return;
	}

	if(*book_position == -2)
	{
		printf("Error: Ya hay un usuario identificado como administrador." \
		" O bien el ID no coincide con el almacenado en el servidor\n");
		Pause;
		return;
	}

	if(*book_position == -3)
	{
		printf("Error: No hay biblioteca cargada actualmente.\n");
		Pause;
		return;
	}

	TPosicion book_position_struct;
	book_position_struct.Ida = id_admin;
	book_position_struct.Pos = *book_position;

	TLibro *book = descargar_1(&book_position_struct, clnt);

	if (book == (TLibro *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	MostrarLibro(book, *book_position, TRUE);

	char buy_books_or_not;

	printf("¿Es este el libro del que deseas comprar más unidades? (s/n): ");
	__fpurge(stdin);
	scanf("%c", &buy_books_or_not);

	if(buy_books_or_not == 's' || buy_books_or_not == 'S')
	{
		int books_bought;

		do
		{
			printf("Introduce número de libros comprados: ");
			__fpurge(stdin);
			scanf("%d", &books_bought);

			if(books_bought <= 0)
			{
				printf("El número de libros comprados debe ser mayor que 0\n");
			}

		} while (books_bought <= 0);
		
		TComRet buy_book;
		buy_book.Ida = id_admin;
		strcpy(buy_book.Isbn, isbn);
		buy_book.NoLibros = books_bought;

		int *buy_result = comprar_1(&buy_book, clnt);

		if (buy_result == (int *)NULL)
		{
			clnt_perror(clnt, "La llamada a la función ha fallado\n");
			Pause;
			return;
		}

		if(*buy_result == -1)
		{
			printf("Error: Ya hay un usuario identificado como administrador." \
			" O bien el ID no coincide con el almacenado en el servidor\n");
			Pause;
			return;
		} 
		else if(*buy_result == 0)
		{
			printf("Error: No hay un libro en la biblioteca que contenga el mismo ISBN\n");
			Pause;
			return;
		}
		else if(*buy_result == 1)
		{
			printf("** Se han añadido los nuevos libros **\n");
			Pause;
			return;
		}
	}
	else
	{
		printf("** Operación de compra abortada **\n");
		Pause;
		return;
	}

}

void handleAdminMenuOption5(int id_admin, CLIENT *clnt)
{
	Cls;

	int *number_of_books = nlibros_1(&id_admin, clnt);

	if (number_of_books == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*number_of_books == 0)
	{
		printf("No hay libros cargados en la biblioteca.\n");
		Pause;
		return;
	}

	Cadena isbn;

	printf("Introduce ISBN a buscar: ");
	__fpurge(stdin);
	scanf("%s", isbn);

	TConsulta search_book;
	strcpy(search_book.Datos, isbn);
	search_book.Ida = id_admin;

	int *book_position = buscar_1(&search_book, clnt);

	if (book_position == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*book_position == -1)
	{
		printf("Error: No se ha encontrado ningún libro con el ISBN indicado.\n");
		Pause;
		return;
	}

	if(*book_position == -2)
	{
		printf("Error: Ya hay un usuario identificado como administrador." \
		" O bien el ID no coincide con el almacenado en el servidor\n");
		Pause;
		return;
	}

	if(*book_position == -3)
	{
		printf("Error: No hay biblioteca cargada actualmente.\n");
		Pause;
		return;
	}

	TPosicion book_position_struct;
	book_position_struct.Ida = id_admin;
	book_position_struct.Pos = *book_position;

	TLibro *book = descargar_1(&book_position_struct, clnt);

	if (book == (TLibro *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	MostrarLibro(book, *book_position, TRUE);

	char discard_books_or_not;

	printf("¿Es este el libro del que deseas retirar unidades? (s/n): ");
	__fpurge(stdin);
	scanf("%c", &discard_books_or_not);

	if(discard_books_or_not == 's' || discard_books_or_not == 'S')
	{
		int books_discarded;

		do
		{
			printf("Introduce número de unidades a retirar: ");
			__fpurge(stdin);
			scanf("%d", &books_discarded);

			if(books_discarded <= 0)
			{
				printf("El número de libros retirados debe ser mayor que 0\n");
			}

		} while (books_discarded <= 0);
		
		TComRet discard_book;
		discard_book.Ida = id_admin;
		strcpy(discard_book.Isbn, isbn);
		discard_book.NoLibros = books_discarded;

		int *discard_result = retirar_1(&discard_book, clnt);

		if (discard_result == (int *)NULL)
		{
			clnt_perror(clnt, "La llamada a la función ha fallado\n");
			Pause;
			return;
		}

		if(*discard_result == -1)
		{
			printf("Error: Ya hay un usuario identificado como administrador." \
			" O bien el ID no coincide con el almacenado en el servidor\n");
			Pause;
			return;
		} 
		else if(*discard_result == 0)
		{
			printf("Error: No hay un libro en la biblioteca que contenga el mismo ISBN\n");
			Pause;
			return;
		}
		else if(*discard_result == 1)
		{
			printf("** Se han retirado el numero de libros indicados **\n");
			Pause;
			return;
		}
		else if(*discard_result == 2)
		{
			printf("Error: no hay suficientes ejemplares disponibles para ser retirados\n");
			Pause;
			return;
		}
	}
	else
	{
		printf("** Operación de retirar libros abortada **\n");
		Pause;
		return;
	}
}

void handleAdminMenuOption6(int id_admin, CLIENT *clnt)
{
	Cls;

	int *number_of_books = nlibros_1(&id_admin, clnt);

	if (number_of_books == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*number_of_books == 0)
	{
		printf("Error: No hay libros cargados en la biblioteca.\n");
		Pause;
		return;
	}

	printf("Código de ordenación\n");
	printf("0.- Por ISBN\n");
	printf("1.- Por Título\n");
	printf("2.- Por Autor\n");
	printf("3.- Por Año\n");
	printf("4.- Por País\n");
	printf("5.- Por Idioma\n");
	printf("6.- Por nº de libros disponibles\n");
	printf("7.- Por nº de libros prestados\n");
	printf("8.- Por nº de libros en espera\n");

	int sorting_field;

	do
	{
		printf("Introduce código: ");
		__fpurge(stdin);
		scanf("%d", &sorting_field);

		if(sorting_field < 0 || sorting_field > 8)
		{
			printf("Error: el código introducido no es válido.\n");
		}

	} while (sorting_field < 0 || sorting_field > 8);

	TOrdenacion sorting_data;
	sorting_data.Campo = sorting_field;
	sorting_data.Ida = id_admin;
	
	bool_t *sorting_result = ordenar_1(&sorting_data, clnt);

	if (sorting_result == (bool_t *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*sorting_result == TRUE)
	{
		printf("** La biblioteca ha sido ordenada correctamente **\n");
		Pause;
	}
	else
	{
		printf("Error: Ya hay un usuario identificado como administrador." \
			" O bien el ID no coincide con el almacenado en el servidor\n");
		Pause;
	}
}

bool_t handleAdminMenuOption7(int id_admin, CLIENT *clnt)
{
	Cls;

	int *number_of_books = nlibros_1(&id_admin, clnt);

	if (number_of_books == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return FALSE;
	}

	if(*number_of_books == 0)
	{
		printf("Error: No hay libros cargados en la biblioteca.\n");
		Pause;
		return FALSE;
	}

	Cadena search_text;

	printf("Introduce el texto a buscar: ");
	__fpurge(stdin);
	scanf("%[^\n]s", search_text);

	printf("Código de búsqueda\n");
	printf("I.- Por ISBN\n");
	printf("T.- Por Título\n");
	printf("A.- Por Autor\n");
	printf("P.- Por País\n");
	printf("D.- Por Idioma\n");
	printf("*.- Por todos los campos\n");
	
	char search_code;

	do
	{
		printf("Introduce código: ");
		__fpurge(stdin);
		scanf("%c", &search_code);

		if (search_code != 'I' && search_code != 'T' && search_code != 'A' 
		&& search_code != 'P' && search_code != 'D' && search_code != '*')
		{
			printf("Error: el código introducido no es válido\n");
		}
	} while (search_code != 'I' && search_code != 'T' && search_code != 'A'
	&& search_code != 'P' && search_code != 'D' && search_code != '*');
	
	return search_library(search_text, search_code, *number_of_books, id_admin, clnt);
}

void handleAdminMenuOption8(int id_admin, CLIENT *clnt)
{
	Cls;

	int *number_of_books = nlibros_1(&id_admin, clnt);

	if (number_of_books == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*number_of_books == 0)
	{
		printf("No hay libros cargados en la biblioteca.\n");
		Pause;
		return;
	}

	printf("Libros en la biblioteca: %d\n", *number_of_books);

	TPosicion position;
	position.Ida = id_admin;

	for (int i = 0; i < *number_of_books; i++)
	{
		position.Pos = i;

		TLibro *book = descargar_1(&position, clnt);

		if (book == (TLibro *)NULL)
		{
			clnt_perror(clnt, "La llamada a la función ha fallado\n");
			Pause;
			return;
		}

		if(i == 0)
		{
			MostrarLibro(book, i, TRUE);
		}
		else
		{
			MostrarLibro(book, i, FALSE);
		}
	}
	
	Pause;
}

void handleMainMenuOption1(CLIENT *clnt)
{
	Cls;

	Cadena password;

	printf("Por favor inserte la contraseña de Administración: ");
	__fpurge(stdin);
	scanf("%s", password);

	int *connection_result = conexion_1(&password, clnt);

	if (connection_result == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if (*connection_result == -1)
	{
		printf("Ya existe un usuario identificado como administrador\n");
		Pause;
	}
	else if (*connection_result == -2)
	{
		printf("Contraseña de administrador incorrecta\n");
		Pause;
	}
	else
	{
		printf("Identificado satisfactoriamente como administrador\n");
		int id_admin = *connection_result;
		Pause;

		int option = -1;

		do
		{
			option = MenuAdministracion();

			if (option == 0)
			{
				handleAdminMenuOption0(id_admin, clnt);
			}
			else if(option == 1)
			{
				handleAdminMenuOption1(id_admin, clnt);
			}
			else if(option == 2)
			{
				handleAdminMenuOption2(id_admin, clnt);
			}
			else if(option == 3)
			{
				handleAdminMenuOption3(id_admin, clnt);
			}
			else if(option == 4)
			{
				handleAdminMenuOption4(id_admin, clnt);
			}
			else if(option == 5)
			{
				handleAdminMenuOption5(id_admin, clnt);
			}
			else if(option == 6)
			{
				handleAdminMenuOption6(id_admin, clnt);
			}
			else if(option == 7)
			{
				handleAdminMenuOption7(id_admin, clnt);
				Pause;
			}
			else if(option == 8)
			{
				handleAdminMenuOption8(id_admin, clnt);
			}

		} while (option != 0);
	}
}

void handleMainMenuOption2(CLIENT *clnt)
{
	handleAdminMenuOption7(-1, clnt);
	Pause;
}

void handleMainMenuOption3(CLIENT *clnt)
{
	int *id_admin = malloc(sizeof(int));
	*id_admin = -1;

	bool_t books_found = handleAdminMenuOption7(-1, clnt);

	if(books_found == FALSE)
	{
		Pause;
		return;
	}

	char take_book;

	do
	{
		printf("¿Quieres sacar algún libro de la biblioteca? (s/n): ");
		__fpurge(stdin);
		scanf("%c", &take_book);

		if(take_book != 's' && take_book != 'S' && take_book != 'n' 
		&& take_book != 'N')
		{
			printf("Error: el carácter introducido no es válido\n");
		}
	} while (take_book != 's' && take_book != 'S' && take_book != 'n' 
		&& take_book != 'N');

	if(take_book == 'n' || take_book == 'N')
	{
		return;
	}
	
	int book_position;

	do
	{
		printf("Introduce la posición del libro a solicitar su préstamo: ");
		__fpurge(stdin);
		scanf("%d", &book_position);

		if(book_position < 0)
		{
			printf("Error: introduzca una posición válida\n");
		}
	} while (book_position < 0);

	TPosicion book_position_argument;
	book_position_argument.Ida = *id_admin;

	//The user sees the position incremented by 1.
	book_position_argument.Pos = book_position - 1;

	int *lend_result = prestar_1(&book_position_argument, clnt);

	if (lend_result == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*lend_result == -1)
	{
		printf("Error: La posición indicada no está dentro de los" \ 
		" límites del vector dinámico.\n");
		Pause;
		return;
	}

	if(*lend_result == -2)
	{
		printf("Error: La biblioteca no está cargada.\n");
		Pause;
		return;
	}

	if(*lend_result == 1)
	{
		printf("** El préstamo se ha concedido, recoge el libro" \
		" en el mostrador. **\n");
		Pause;
		return;
	}

	if(*lend_result == 0)
	{
		printf("Error: No hay ejemplares disponibles actualmente, se" \
		" le ha puesto en la lista de espera.\n");
		Pause;
		return;
	}
}

void handleMainMenuOption4(CLIENT *clnt)
{
	int *id_admin = malloc(sizeof(int));
	*id_admin = -1;

	bool_t books_found = handleAdminMenuOption7(-1, clnt);

	if(books_found == FALSE)
	{
		Pause;
		return;
	}

	char return_book;

	do
	{
		printf("¿Quieres devolver algún libro de la biblioteca? (s/n): ");
		__fpurge(stdin);
		scanf("%c", &return_book);

		if(return_book != 's' && return_book != 'S' && return_book != 'n' 
		&& return_book != 'N')
		{
			printf("Error: el carácter introducido no es válido\n");
		}
	} while (return_book != 's' && return_book != 'S' && return_book != 'n' 
		&& return_book != 'N');

	if(return_book == 'n' || return_book == 'N')
	{
		return;
	}
	
	int book_position;

	do
	{
		printf("Introduce la posición del libro a devolver: ");
		__fpurge(stdin);
		scanf("%d", &book_position);

		if(book_position < 0)
		{
			printf("Error: introduzca una posición válida\n");
		}
	} while (book_position < 0);

	TPosicion book_position_argument;
	book_position_argument.Ida = *id_admin;

	//The user sees the position incremented by 1.
	book_position_argument.Pos = book_position - 1;

	int *return_result = devolver_1(&book_position_argument, clnt);

	if (return_result == (int *)NULL)
	{
		clnt_perror(clnt, "La llamada a la función ha fallado\n");
		Pause;
		return;
	}

	if(*return_result == -1)
	{
		printf("Error: La posición indicada no está dentro de los" \ 
		" límites del vector dinámico.\n");
		Pause;
		return;
	}

	if(*return_result == -2)
	{
		printf("Error: La biblioteca no está cargada.\n");
		Pause;
		return;
	}

	if(*return_result == 1)
	{
		printf("** Se ha devuelto el libro y puesto en la " \
		"estantería **\n");
		Pause;
		return;
	}

	if(*return_result == 0)
	{
		printf("** Se ha devuelto el libro y dado a una persona en " \ 
		"lista de espera **\n");
		Pause;
		return;
	}

	if(*return_result == 2)
	{
		printf("Error: El libro no se puede devolver, porque no hay " \ 
		"usuarios en lista de espera ni libros prestados\n");
		Pause;
		return;
	}
}

int main(int argc, char *argv[])
{
	char *host;

	if (argc < 2)
	{
		printf("usage: %s server_host\n", argv[0]);
		exit(1);
	}
	host = argv[1];

	CLIENT *clnt;
	int opcion;

	clnt = clnt_create(host, GESTORBIBLIOTECA, GESTORBIBLIOTECA_VER, "tcp");

	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}

	printf("Cliente: Conexión con el servidor adquirida.\n\n");

	do
	{
		opcion = MenuPrincipal();

		if (opcion == 1)
		{
			handleMainMenuOption1(clnt);
		}
		else if(opcion == 2)
		{
			handleMainMenuOption2(clnt);
		}
		else if(opcion == 3)
		{
			handleMainMenuOption3(clnt);
		}
		else if(opcion == 4)
		{
			handleMainMenuOption4(clnt);
		}

	} while (opcion != 0);

	// gestorbiblioteca_1 (host);
	clnt_destroy(clnt);
	exit(0);
}
